package db.prob.datalog.query.Absyn; // Java Package generated by the BNF Converter.

import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;

public class Query {
    private String name_;
    private Set<String> head_;
    private List<Literal> body_;

    private Set<String> rels_;
    private Set<String> prels_;
    private Set<String> attr_;

    private void set_attr() {
        Set<String> attr = new HashSet<String>();
        for (Literal b : this.body_) {
            attr.addAll(b.get_attr());
        }
        this.attr_ = attr;
    }

    private void set_allrels() {
        Set<String> prob_rel_set = new HashSet<String>();
        Set<String> rel_set = new HashSet<String>();
        for (Literal rel : this.body_) {
            if (rel instanceof Relation) {
                Relation rel_obj = (Relation) rel;
                if (rel_obj.probabilistic) {
                    prob_rel_set.add(rel_obj.name_);
                } else {
                    rel_set.add(rel_obj.name_);
                }

            }
        }
        this.rels_ = rel_set;
    }

    public Query(String name, Set<String> head, List<Literal> body) {
        name_ = name;
        head_ = head;
        body_ = body;

        set_attr();
        set_allrels();
    }

    public Set<String> rels() {
        return rels_;
    }

    public Set<String> prels() {
        return prels_;
    }

    public Set<String> attr() {
        return attr_;
    }

    public Set<String> head() {
        return head_;
    }

    public boolean is_separete(String Rel_a, String Rel_b) {
        return !is_connected(Rel_a, Rel_b);
    }

    private Relation body_get_relation(String relation_name) {
        for (Literal l : this.body_) {
            if (l instanceof Relation) {
                Relation l_relation = (Relation) l;
                if (l_relation.name_ == relation_name) {
                    return l_relation;
                }
            }
        }
        return null;
    }

    /*
        select_set : set of attributes which LiterlEQ should be in
     */
    private List<LiteralEQ> body_get_literaleq_by_set(Set<String> req_set) {
        List<LiteralEQ> leq_list = new LinkedList<LiteralEQ>();
        for (Literal l : this.body_) {
            if (l instanceof LiteralEQ) {
                LiteralEQ leq = (LiteralEQ) l;
                if (req_set.containsAll(leq.get_terms())) ;
                leq_list.add(leq);
            }
        }
        return leq_list;
    }

    /*
        tests if only one part of leq is in head
     */
    private boolean test_connected(LiteralEQ leq) {
        // connection is how much of leq in head
        int connection = 0;
        if (this.head_.contains(leq.term_right_)) {
            connection++;
        }
        if (this.head_.contains(leq.term_left_)) {
            connection++;
        }
        return connection == 1;
    }

    /*
        assumes no literalEQ s.t. R1.a = R1.b
        so they are always for different Relations

        also assumes field names are different
     */
    public boolean is_connected(String rel_a, String rel_b) {
        // Rel_a, Rel_b in Rels(q)
        // if there's R.A=R.B and either is not in Head(q)
        Set<String> set_from_rels = new HashSet<String>();
        Relation Ra = this.body_get_relation(rel_a);
        Set<String> Ra_attr_set = Ra.get_attr();
        set_from_rels.addAll(Ra_attr_set);

        Relation Rb = this.body_get_relation(rel_b);
        Set<String> Rb_attr_set = Rb.get_attr();
        set_from_rels.addAll(Rb_attr_set);

        boolean is_connected = false;
        List<LiteralEQ> leq_body = this.body_get_literaleq_by_set(set_from_rels);
        for (LiteralEQ leq : leq_body) {
            is_connected = this.test_connected(leq);
            if (is_connected) {
                return is_connected;
            }
        }
        return is_connected;
    }

    public boolean is_separate(String Ra, String Rb) {
        return !this.is_connected(Ra, Rb);
    }

    public boolean is_projection_safe(String query_added_attribute) {
        // TODO
        // let A = attr + query_added_attributes
        // for every R^p in PRels(q)
        // Gamma := A, R^p.E ==> head(q)
        return false;
    }
}